import { _ as _export_sfc, c as createElementBlock, o as openBlock, ai as createStaticVNode } from "./chunks/framework.DTJYUGiV.js";
const _imports_0 = "/PromptingTools.jl/previews/PR306/assets/rag_diagram_highlevel.D_aLugML.png";
const _imports_1 = "/PromptingTools.jl/previews/PR306/assets/rag_diagram_detailed._BjqL9Ae.png";
const __pageData = JSON.parse('{"title":"RAG Tools Introduction","description":"","frontmatter":{},"headers":[],"relativePath":"extra_tools/rag_tools_intro.md","filePath":"extra_tools/rag_tools_intro.md","lastUpdated":null}');
const _sfc_main = { name: "extra_tools/rag_tools_intro.md" };
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", null, _cache[0] || (_cache[0] = [
    createStaticVNode('<h1 id="RAG-Tools-Introduction" tabindex="-1">RAG Tools Introduction <a class="header-anchor" href="#RAG-Tools-Introduction" aria-label="Permalink to &quot;RAG Tools Introduction {#RAG-Tools-Introduction}&quot;">​</a></h1><div class="important custom-block github-alert"><p class="custom-block-title">**RAGTools has moved to a separate package since PromptingTools v0.75!** This documentation demonstrates the RAG ecosystem but all functionality is now in [RAGTools.jl](https://github.com/JuliaGenAI/RAGTools.jl). See our [Migration Guide](ragtools_migration.md) for details.</p><p></p></div><p><code>RAGTools</code> provides a set of utilities for building Retrieval-Augmented Generation (RAG) applications - applications that generate answers by combining knowledge of the underlying AI model with information from your knowledge base.</p><p>The examples below showcase the powerful and flexible RAG ecosystem available in Julia. You can extend any step of the pipeline with your own custom code, or use the provided defaults to get started quickly.</p><p>Import the module as follows:</p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Import the dedicated RAGTools package </span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">using</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> RAGTools</span></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># For accessing unexported functionality</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> RT </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> RAGTools</span></span></code></pre></div><div class="note custom-block github-alert"><p class="custom-block-title">Since PromptingTools v0.75, RAGTools is a separate package. Install it with `using Pkg; Pkg.add(&quot;RAGTools&quot;)`. The API remains identical - only the import changes!</p><p></p></div><h2 id="Highlights" tabindex="-1">Highlights <a class="header-anchor" href="#Highlights" aria-label="Permalink to &quot;Highlights {#Highlights}&quot;">​</a></h2><p>The main functions to be aware of are:</p><ul><li><p><code>build_index</code> to build a RAG index from a list of documents (type <code>ChunkIndex</code>)</p></li><li><p><code>airag</code> to generate answers using the RAG model on top of the <code>index</code> built above</p><ul><li><p><code>retrieve</code> to retrieve relevant chunks from the index for a given question</p></li><li><p><code>generate!</code> to generate an answer from the retrieved chunks</p></li></ul></li><li><p><code>annotate_support</code> to highlight which parts of the RAG answer are supported by the documents in the index vs which are generated by the model, it is applied automatically if you use pretty printing with <code>pprint</code> (eg, <code>pprint(result)</code>)</p></li><li><p><code>build_qa_evals</code> to build a set of question-answer pairs for evaluation of the RAG model from your corpus</p></li></ul><p>The hope is to provide a modular and easily extensible set of tools for building RAG applications in Julia. Feel free to open an issue or ask in the <code>#generative-ai</code> channel in the JuliaLang Slack if you have a specific need.</p><h2 id="Examples" tabindex="-1">Examples <a class="header-anchor" href="#Examples" aria-label="Permalink to &quot;Examples {#Examples}&quot;">​</a></h2><p>Let&#39;s build an index, we need to provide a starter list of documents:</p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">sentences </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span></span>\n<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    &quot;Find the most comprehensive guide on Julia programming language for beginners published in 2023.&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>\n<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    &quot;Search for the latest advancements in quantum computing using Julia language.&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>\n<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    &quot;How to implement machine learning algorithms in Julia with examples.&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>\n<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    &quot;Looking for performance comparison between Julia, Python, and R for data analysis.&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>\n<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    &quot;Find Julia language tutorials focusing on high-performance scientific computing.&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>\n<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    &quot;Search for the top Julia language packages for data visualization and their documentation.&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>\n<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    &quot;How to set up a Julia development environment on Windows 10.&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>\n<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    &quot;Discover the best practices for parallel computing in Julia.&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>\n<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    &quot;Search for case studies of large-scale data processing using Julia.&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>\n<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    &quot;Find comprehensive resources for mastering metaprogramming in Julia.&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>\n<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    &quot;Looking for articles on the advantages of using Julia for statistical modeling.&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>\n<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    &quot;How to contribute to the Julia open-source community: A step-by-step guide.&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>\n<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    &quot;Find the comparison of numerical accuracy between Julia and MATLAB.&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>\n<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    &quot;Looking for the latest Julia language updates and their impact on AI research.&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>\n<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    &quot;How to efficiently handle big data with Julia: Techniques and libraries.&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>\n<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    &quot;Discover how Julia integrates with other programming languages and tools.&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>\n<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    &quot;Search for Julia-based frameworks for developing web applications.&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>\n<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    &quot;Find tutorials on creating interactive dashboards with Julia.&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>\n<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    &quot;How to use Julia for natural language processing and text analysis.&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>\n<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    &quot;Discover the role of Julia in the future of computational finance and econometrics.&quot;</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span></code></pre></div><p>Let&#39;s index these &quot;documents&quot;:</p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">index </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> build_index</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(sentences; chunker_kwargs</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(; sources</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">map</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;Doc</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">$i</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(sentences))))</span></span></code></pre></div><p>This would be equivalent to the following <code>index = build_index(SimpleIndexer(), sentences)</code> which dispatches to the default implementation of each step via the <code>SimpleIndexer</code> struct. We provide these default implementations for the main functions as an optional argument - no need to provide them if you&#39;re running the default pipeline.</p><p>Notice that we have provided a <code>chunker_kwargs</code> argument to the <code>build_index</code> function. These will be kwargs passed to <code>chunker</code> step.</p><p>Now let&#39;s generate an answer to a question.</p><ol><li>Run end-to-end RAG (retrieve + generate!), return <code>AIMessage</code></li></ol><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">question </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;What are the best practices for parallel computing in Julia?&quot;</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">msg </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> airag</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(index; question) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># short for airag(RAGConfig(), index; question)</span></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">## Output:</span></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">## [ Info: Done with RAG. Total cost: \\$0.0</span></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">## AIMessage(&quot;Some best practices for parallel computing in Julia include us...</span></span></code></pre></div><ol><li>Explore what&#39;s happening under the hood by changing the return type - <code>RAGResult</code> contains all intermediate steps.</li></ol><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">result </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> airag</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(index; question, return_all</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">## RAGResult</span></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">##   question: String &quot;What are the best practices for parallel computing in Julia?&quot;</span></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">##   rephrased_questions: Array{String}((1,))</span></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">##   answer: SubString{String}</span></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">##   final_answer: SubString{String}</span></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">##   context: Array{String}((5,))</span></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">##   sources: Array{String}((5,))</span></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">##   emb_candidates: CandidateChunks{Int64, Float32}</span></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">##   tag_candidates: CandidateChunks{Int64, Float32}</span></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">##   filtered_candidates: CandidateChunks{Int64, Float32}</span></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">##   reranked_candidates: CandidateChunks{Int64, Float32}</span></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">##   conversations: Dict{Symbol, Vector{&lt;:PromptingTools.AbstractMessage}}</span></span></code></pre></div><p>You can still get the message from the result, see <code>result.conversations[:final_answer]</code> (the dictionary keys correspond to the function names of those steps).</p><ol><li>If you need to customize it, break the pipeline into its sub-steps: retrieve and generate - RAGResult serves as the intermediate result.</li></ol><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Retrieve which chunks are relevant to the question</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">result </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> retrieve</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(index, question)</span></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Generate an answer</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">result </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> generate!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(index, result)</span></span></code></pre></div><p>You can leverage a pretty-printing system with <code>pprint</code> where we automatically annotate the support of the answer by the chunks we provided to the model. It is configurable and you can select only some of its functions (eg, scores, sources).</p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">pprint</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(result)</span></span></code></pre></div><p>You&#39;ll see the following in REPL but with COLOR highlighting in the terminal.</p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>--------------------</span></span>\n<span class="line"><span>QUESTION(s)</span></span>\n<span class="line"><span>--------------------</span></span>\n<span class="line"><span>- What are the best practices for parallel computing in Julia?</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>--------------------</span></span>\n<span class="line"><span>ANSWER</span></span>\n<span class="line"><span>--------------------</span></span>\n<span class="line"><span>Some of the best practices for parallel computing in Julia include:[1,0.7]</span></span>\n<span class="line"><span>- Using [3,0.4]`@threads` for simple parallelism[1,0.34]</span></span>\n<span class="line"><span>- Utilizing `Distributed` module for more complex parallel tasks[1,0.19]</span></span>\n<span class="line"><span>- Avoiding excessive memory allocation</span></span>\n<span class="line"><span>- Considering task granularity for efficient workload distribution</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>--------------------</span></span>\n<span class="line"><span>SOURCES</span></span>\n<span class="line"><span>--------------------</span></span>\n<span class="line"><span>1. Doc8</span></span>\n<span class="line"><span>2. Doc15</span></span>\n<span class="line"><span>3. Doc5</span></span>\n<span class="line"><span>4. Doc2</span></span>\n<span class="line"><span>5. Doc9</span></span></code></pre></div><p>See <code>?print_html</code> for the HTML version of the pretty-printing and styling system, eg, when you want to display the results in a web application based on Genie.jl/Stipple.jl.</p><p><strong>How to read the output</strong></p><ul><li><p>Color legend:</p><ul><li><p>No color: High match with the context, can be trusted more</p></li><li><p>Blue: Partial match against some words in the context, investigate</p></li><li><p>Magenta (Red): No match with the context, fully generated by the model</p></li></ul></li><li><p>Square brackets: The best matching context ID + Match score of the chunk (eg, <code>[3,0.4]</code> means the highest support for the sentence is from the context chunk number 3 with a 40% match).</p></li></ul><p>Want more?</p><p>See <code>examples/building_RAG.jl</code> for a comprehensive example. Note that examples now use <code>using RAGTools</code> instead of the experimental module.</p><div class="tip custom-block github-alert"><p class="custom-block-title">**Migrating from PromptingTools.Experimental.RAGTools?** Check out our detailed [Migration Guide](ragtools_migration.md) with step-by-step instructions and examples.</p><p></p></div><h2 id="RAG-Interface" tabindex="-1">RAG Interface <a class="header-anchor" href="#RAG-Interface" aria-label="Permalink to &quot;RAG Interface {#RAG-Interface}&quot;">​</a></h2><h3 id="System-Overview" tabindex="-1">System Overview <a class="header-anchor" href="#System-Overview" aria-label="Permalink to &quot;System Overview {#System-Overview}&quot;">​</a></h3><p>This system is designed for information retrieval and response generation, structured in three main phases:</p><ul><li><p>Preparation, when you create an instance of <code>AbstractIndex</code></p></li><li><p>Retrieval, when you surface the top most relevant chunks/items in the <code>index</code> and return <code>AbstractRAGResult</code>, which contains the references to the chunks (<code>AbstractCandidateChunks</code>)</p></li><li><p>Generation, when you generate an answer based on the context built from the retrieved chunks, return either <code>AIMessage</code> or <code>AbstractRAGResult</code></p></li></ul><p>The corresponding functions are <code>build_index</code>, <code>retrieve</code>, and <code>generate!</code>, respectively. Here is the high-level diagram that shows the signature of the main functions:</p><p><img src="' + _imports_0 + '" alt=""></p><p>Notice that the first argument is a custom type for multiple dispatch. In addition, observe the &quot;kwargs&quot; names, that&#39;s how the keyword arguments for each function are passed down from the higher-level functions (eg, <code>build_index(...; chunker_kwargs=(; separators=...)))</code>). It&#39;s the simplest way to customize some step of the pipeline (eg, set a custom model with a <code>model</code> kwarg or prompt template with <code>template</code> kwarg).</p><p>The system is designed to be hackable and extensible at almost every entry point. If you want to customize the behavior of any step, you can do so by defining a new type and defining a new method for the step you&#39;re changing, eg,</p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">PromptingTools</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Experimental</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">RAGTools</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> rerank</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> MyReranker </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> AbstractReranker</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> end</span></span>\n<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">rerank</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">MyReranker</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, index, candidates) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ...</span></span></code></pre></div><p>And then you would set the <code>retrive</code> step to use your custom <code>MyReranker</code> via <code>reranker</code> kwarg, eg, <code>retrieve(....; reranker = MyReranker())</code> (or customize the main dispatching <code>AbstractRetriever</code> struct).</p><p>The overarching principles are:</p><ul><li><p>Always dispatch / customize the behavior by defining a new <code>Struct</code> and the corresponding method for the existing functions (eg, <code>rerank</code> function for the re-ranking step).</p></li><li><p>Custom types are provided as the first argument (the high-level functions will work without them as we provide some defaults).</p></li><li><p>Custom types do NOT have any internal fields or DATA (with the exception of managing sub-steps of the pipeline like <code>AbstractRetriever</code> or <code>RAGConfig</code>).</p></li><li><p>Additional data should be passed around as keyword arguments (eg, <code>chunker_kwargs</code> in <code>build_index</code> to pass data to the chunking step). The intention was to have some clearly documented default values in the docstrings of each step + to have the various options all in one place.</p></li></ul><h3 id="RAG-Diagram" tabindex="-1">RAG Diagram <a class="header-anchor" href="#RAG-Diagram" aria-label="Permalink to &quot;RAG Diagram {#RAG-Diagram}&quot;">​</a></h3><p><img src="' + _imports_1 + '" alt=""></p><p><strong>The main functions are</strong>:</p><p>Prepare your document index with <code>build_index</code>:</p><ul><li><p>signature: <code>(indexer::AbstractIndexBuilder, files_or_docs::Vector{&lt;:AbstractString}) -&gt; AbstractChunkIndex</code></p></li><li><p>flow: <code>get_chunks</code> -&gt; <code>get_embeddings</code> -&gt; <code>get_tags</code> -&gt; <code>build_tags</code></p></li><li><p>dispatch types: <code>AbstractIndexBuilder</code>, <code>AbstractChunker</code>, <code>AbstractEmbedder</code>, <code>AbstractTagger</code></p></li></ul><p>Run E2E RAG with <code>airag</code>:</p><ul><li><p>signature: <code>(cfg::AbstractRAGConfig, index::AbstractChunkIndex; question::AbstractString)</code> -&gt; <code>AIMessage</code> or <code>AbstractRAGResult</code></p></li><li><p>flow: <code>retrieve</code> -&gt; <code>generate!</code></p></li><li><p>dispatch types: <code>AbstractRAGConfig</code>, <code>AbstractRetriever</code>, <code>AbstractGenerator</code></p></li></ul><p>Retrieve relevant chunks with <code>retrieve</code>:</p><ul><li><p>signature: <code>(retriever::AbstractRetriever, index::AbstractChunkIndex, question::AbstractString) -&gt; AbstractRAGResult</code></p></li><li><p>flow: <code>rephrase</code> -&gt; <code>get_embeddings</code> -&gt; <code>find_closest</code> -&gt; <code>get_tags</code> -&gt; <code>find_tags</code> -&gt; <code>rerank</code></p></li><li><p>dispatch types: <code>AbstractRAGConfig</code>, <code>AbstractRephraser</code>, <code>AbstractEmbedder</code>, <code>AbstractSimilarityFinder</code>, <code>AbstractTagger</code>, <code>AbstractTagFilter</code>, <code>AbstractReranker</code></p></li></ul><p>Generate an answer from relevant chunks with <code>generate!</code>:</p><ul><li><p>signature: <code>(generator::AbstractGenerator, index::AbstractChunkIndex, result::AbstractRAGResult)</code> -&gt; <code>AIMessage</code> or <code>AbstractRAGResult</code></p></li><li><p>flow: <code>build_context!</code> -&gt; <code>answer!</code> -&gt; <code>refine!</code> -&gt; <code>postprocess!</code></p></li><li><p>dispatch types: <code>AbstractGenerator</code>, <code>AbstractContextBuilder</code>, <code>AbstractAnswerer</code>, <code>AbstractRefiner</code>, <code>AbstractPostprocessor</code></p></li></ul><p>To discover the currently available implementations, use <code>subtypes</code> function, eg, <code>subtypes(AbstractReranker)</code>.</p><h4 id="Passing-Keyword-Arguments" tabindex="-1">Passing Keyword Arguments <a class="header-anchor" href="#Passing-Keyword-Arguments" aria-label="Permalink to &quot;Passing Keyword Arguments {#Passing-Keyword-Arguments}&quot;">​</a></h4><p>If you need to pass keyword arguments, use the nested kwargs corresponding to the dispatch type names (<code>rephrase</code> step, has <code>rephraser</code> dispatch type and <code>rephraser_kwargs</code> for its keyword arguments).</p><p>For example:</p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">cfg </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> RAGConfig</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(; retriever </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> AdvancedRetriever</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># kwargs will be big and nested, let&#39;s prepare them upfront</span></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># we specify &quot;custom&quot; model for each component that calls LLM</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">kwargs </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    retriever </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> AdvancedRetriever</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(),</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    retriever_kwargs </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (;</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        top_k </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 100</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        top_n </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        # notice that this is effectively: retriever_kwargs/rephraser_kwargs/template</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        rephraser_kwargs </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (;</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            template </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> :RAGQueryHyDE</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            model </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;custom&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)),</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    generator_kwargs </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (;</span></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        # pass kwargs to `answer!` step defined by the `answerer` -&gt; we&#39;re setting `answerer_kwargs`</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        answerer_kwargs </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (;</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            model </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;custom&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">),</span></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    # api_kwargs can be shared across all components</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    api_kwargs </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (;</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        url </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;http://localhost:8080&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)))</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">result </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> airag</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(cfg, index, question; kwargs</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>If you were one level deeper in the pipeline, working with retriever directly, you would pass:</p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">retriever_kwargs </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (;</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    top_k </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 100</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    top_n </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    # notice that this is effectively: rephraser_kwargs/template</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    rephraser_kwargs </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (;</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      template </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> :RAGQueryHyDE</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      model </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;custom&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">),</span></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  # api_kwargs can be shared across all components</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  api_kwargs </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (;</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      url </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;http://localhost:8080&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">))</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">result </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> retrieve</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AdvancedRetriever</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(), index, question; retriever_kwargs</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>And going even deeper, you would provide the <code>rephraser_kwargs</code> directly to the <code>rephrase</code> step, eg,</p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">rephrase</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">SimpleRephraser</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(), question; model</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;custom&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, template </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> :RAGQueryHyDE</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, api_kwargs </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (; url </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;http://localhost:8080&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">))</span></span></code></pre></div><h3 id="Deepdive" tabindex="-1">Deepdive <a class="header-anchor" href="#Deepdive" aria-label="Permalink to &quot;Deepdive {#Deepdive}&quot;">​</a></h3><p><strong>Preparation Phase:</strong></p><ul><li><p>Begins with <code>build_index</code>, which creates a user-defined index type from an abstract chunk index using specified dels and function strategies.</p></li><li><p><code>get_chunks</code> then divides the indexed data into manageable pieces based on a chunking strategy.</p></li><li><p><code>get_embeddings</code> generates embeddings for each chunk using an embedding strategy to facilitate similarity arches.</p></li><li><p>Finally, <code>get_tags</code> extracts relevant metadata from each chunk, enabling tag-based filtering (hybrid search index). If there are <code>tags</code> available, <code>build_tags</code> is called to build the corresponding sparse matrix for filtering with tags.</p></li></ul><p><strong>Retrieval Phase:</strong></p><ul><li><p>The <code>retrieve</code> step is intended to find the most relevant chunks in the <code>index</code>.</p></li><li><p><code>rephrase</code> is called first, if we want to rephrase the query (methods like <code>HyDE</code> can improve retrieval quite a bit)!</p></li><li><p><code>get_embeddings</code> generates embeddings for the original + rephrased query</p></li><li><p><code>find_closest</code> looks up the most relevant candidates (<code>CandidateChunks</code>) using a similarity search strategy.</p></li><li><p><code>get_tags</code> extracts the potential tags (can be provided as part of the <code>airag</code> call, eg, when we want to use only some small part of the indexed chunks)</p></li><li><p><code>find_tags</code> filters the candidates to strictly match <em>at least one</em> of the tags (if provided)</p></li><li><p><code>rerank</code> is called to rerank the candidates based on the reranking strategy (ie, to improve the ordering of the chunks in context).</p></li></ul><p><strong>Generation Phase:</strong></p><ul><li><p>The <code>generate!</code> step is intended to generate a response based on the retrieved chunks, provided via <code>AbstractRAGResult</code> (eg, <code>RAGResult</code>).</p></li><li><p><code>build_context!</code> constructs the context for response generation based on a context strategy and applies the necessary formatting</p></li><li><p><code>answer!</code> generates the response based on the context and the query</p></li><li><p><code>refine!</code> is called to refine the response (optional, defaults to passthrough)</p></li><li><p><code>postprocessing!</code> is available for any final touches to the response or to potentially save or format the results (eg, automatically save to the disk)</p></li></ul><p>Note that all generation steps are mutating the <code>RAGResult</code> object.</p><p>See more details and corresponding functions and types in <code>src/Experimental/RAGTools/rag_interface.jl</code>.</p>', 77)
  ]));
}
const rag_tools_intro = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render]]);
export {
  __pageData,
  rag_tools_intro as default
};
