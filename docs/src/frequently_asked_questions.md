# Frequently Asked Questions

## Why OpenAI

OpenAI's models are at the forefront of AI research and provide robust, state-of-the-art capabilities for many tasks.

There will be situations not or cannot use it (eg, privacy, cost, etc.). In that case, you can use local models (eg, Ollama) or other APIs (eg, Anthropic).

Note: To get started with [Ollama.ai](https://ollama.ai/), see the [Setup Guide for Ollama](#setup-guide-for-ollama) section below.

## Data Privacy and OpenAI

At the time of writing, OpenAI does NOT use the API calls for training their models.

> **API**
> 
> OpenAI does not use data submitted to and generated by our API to train OpenAI models or improve OpenAI’s service offering. In order to support the continuous improvement of our models, you can fill out this form to opt-in to share your data with us. -- [How your data is used to improve our models](https://help.openai.com/en/articles/5722486-how-your-data-is-used-to-improve-model-performance)

You can always double-check the latest information on the [OpenAI's How we use your data](https://platform.openai.com/docs/models/how-we-use-your-data) page.

Resources:
- [OpenAI's How we use your data](https://platform.openai.com/docs/models/how-we-use-your-data)
- [Data usage for consumer services FAQ](https://help.openai.com/en/articles/7039943-data-usage-for-consumer-services-faq)
- [How your data is used to improve our models](https://help.openai.com/en/articles/5722486-how-your-data-is-used-to-improve-model-performance)


## Creating OpenAI API Key

You can get your API key from OpenAI by signing up for an account and accessing the API section of the OpenAI website.

1. Create an account with [OpenAI](https://platform.openai.com/signup)
2. Go to [API Key page](https://platform.openai.com/account/api-keys)
3. Click on “Create new secret key”
  !!! Do not share it with anyone and do NOT save it to any files that get synced online.

Resources:
- [OpenAI Documentation](https://platform.openai.com/docs/quickstart?context=python)
- [Visual tutorial](https://www.maisieai.com/help/how-to-get-an-openai-api-key-for-chatgpt)

Pro tip: Always set the spending limits!

## Getting an error "ArgumentError: api_key cannot be empty" despite having set `OPENAI_API_KEY`?

Quick fix: just provide kwarg `api_key` with your key to the `aigenerate` function (and other `ai*` functions).

This error is thrown when the OpenAI API key is not available in 1) local preferences or 2) environment variables (`ENV["OPENAI_API_KEY"]`).

First, check if you can access the key by running `ENV["OPENAI_API_KEY"]` in the Julia REPL. If it returns `nothing`, the key is not set.

If the key is set, but you still get the error, there was a rare bug in earlier versions where if you first precompiled PromptingTools without the API key, it would remember it and "compile away" the `get(ENV,...)` function call. If you're experiencing this bug on the latest version of PromptingTools, please open an issue on GitHub.

The solution is to force a new precompilation, so you can do any of the below:
1) Force precompilation (run `Pkg.precompile()` in the Julia REPL)
2) Update the PromptingTools package (runs precompilation automatically)
3) Delete your compiled cache in `.julia` DEPOT (usually `.julia/compiled/v1.10/PromptingTools`). You can do it manually in the file explorer or via Julia REPL: `rm("~/.julia/compiled/v1.10/PromptingTools", recursive=true, force=true)`

## Setting OpenAI Spending Limits

OpenAI allows you to set spending limits directly on your account dashboard to prevent unexpected costs.

1. Go to [OpenAI Billing](https://platform.openai.com/account/billing)
2. Set Soft Limit (you’ll receive a notification) and Hard Limit (API will stop working not to spend more money)
 
A good start might be a soft limit of c.$5 and a hard limit of c.$10 - you can always increase it later in the month.

Resources:
- [OpenAI Forum](https://community.openai.com/t/how-to-set-a-price-limit/13086)

### How much does it cost? Is it worth paying for?

If you use a local model (eg, with Ollama), it's free. If you use any commercial APIs (eg, OpenAI), you will likely pay per "token" (a sub-word unit).

For example, a simple request with a simple question and 1 sentence response in return (”Is statement XYZ a positive comment”) will cost you ~$0.0001 (ie, one-hundredth of a cent)

**Is it worth paying for?**

GenAI is a way to buy time! You can pay cents to save tens of minutes every day.

Continuing the example above, imagine you have a table with 200 comments. Now, you can parse each one of them with an LLM for the features/checks you need. 
Assuming the price per call was $0.0001, you'd pay 2 cents for the job and save 30-60 minutes of your time!


Resources:
- [OpenAI Pricing per 1000 tokens](https://openai.com/pricing)

## Configuring the Environment Variable for API Key

This is a guide for OpenAI's API key, but it works for any other API key you might need (eg, `MISTRALAI_API_KEY` for MistralAI API).

To use the OpenAI API with PromptingTools.jl, set your API key as an environment variable:

```julia
ENV["OPENAI_API_KEY"] = "your-api-key"
```

As a one-off, you can: 
- set it in the terminal before launching Julia: `export OPENAI_API_KEY = <your key>`
- set it in your `setup.jl` (make sure not to commit it to GitHub!)

Make sure to start Julia from the same terminal window where you set the variable.
Easy check in Julia, run `ENV["OPENAI_API_KEY"]` and you should see your key!

A better way:
- On a Mac, add the configuration line to your terminal's configuration file (eg, `~/.zshrc`). It will get automatically loaded every time you launch the terminal
- On Windows, set it as a system variable in "Environment Variables" settings (see the Resources)

Resources: 
- [OpenAI Guide](https://platform.openai.com/docs/quickstart?context=python)

## Setting the API Key via Preferences.jl

You can also set the API key in `LocalPreferences.toml`, so it persists across sessions and projects.

Use: `PromptingTools.set_preferences!("OPENAI_API_KEY"="your-api-key")`

To double-check, run `PromptingTools.get_preferences("OPENAI_API_KEY")` and you should see your key!

See more detail in the `?PromptingTools.PREFERENCES` docstring.

## Understanding the API Keyword Arguments in `aigenerate` (`api_kwargs`)
  
See [OpenAI API reference](https://platform.openai.com/docs/guides/text-generation/chat-completions-api) for more information.

## Instant Access from Anywhere

For easy access from anywhere, add PromptingTools into your `startup.jl` (can be found in `~/.julia/config/startup.jl`).

Add the following snippet:
```
using PromptingTools
const PT = PromptingTools # to access unexported functions and types
```

Now, you can just use `ai"Help me do X to achieve Y"` from any REPL session!

## Open Source Alternatives

The ethos of PromptingTools.jl is to allow you to use whatever model you want, which includes Open Source LLMs. The most popular and easiest to setup is [Ollama.ai](https://ollama.ai/) - see below for more information.

## Setup Guide for Ollama

Ollama runs a background service hosting LLMs that you can access via a simple API. It's especially useful when you're working with some sensitive data that should not be sent anywhere.

Installation is very easy, just download the latest version [here](https://ollama.ai/download).

Once you've installed it, just launch the app and you're ready to go!

To check if it's running, go to your browser and open `127.0.0.1:11434`. You should see the message "Ollama is running". 
Alternatively, you can run `ollama serve` in your terminal and you'll get a message that it's already running.

There are many models available in [Ollama Library](https://ollama.ai/library), including Llama2, CodeLlama, SQLCoder, or my personal favorite `openhermes2.5-mistral`.

Download new models with `ollama pull <model_name>` (eg, `ollama pull openhermes2.5-mistral`). 

Show currently available models with `ollama list`.

See [Ollama.ai](https://ollama.ai/) for more information.

## Changing the Default Model or Schema

If you tend to use non-default options, it can get tedious to specify `PT.*` every time.

There are three ways how you can customize your workflows (especially when you use Ollama or other local models):

1) Import the functions/types you need explicitly at the top (eg, `using PromptingTools: OllamaSchema`)
2) Register your model and its associated schema  (`PT.register_model!(; name="123", schema=PT.OllamaSchema())`). You won't have to specify the schema anymore only the model name. See [Working with Ollama](#working-with-ollama) for more information.
3) Override your default model (`PT.MODEL_CHAT`) and schema (`PT.PROMPT_SCHEMA`). It can be done persistently with Preferences, eg, `PT.set_preferences!("PROMPT_SCHEMA" => "OllamaSchema", "MODEL_CHAT"=>"llama2")`.

## How to have a Multi-turn Conversations?

Let's say you would like to respond back to a model's response. How to do it?

1) With `ai""` macro
The simplest way if you used `ai""` macro, is to send a reply with the `ai!""` macro. It will use the last response as the conversation.
```julia
ai"Hi! I'm John"

ai!"What's my name?"
# Return: "Your name is John."
```

2) With `aigenerate` function
You can use the `conversation` keyword argument to pass the previous conversation (in all `ai*` functions). It will prepend the past `conversation` before sending the new request to the model.

To get the conversation, set `return_all=true` and store the whole conversation thread (not just the last message) in a variable. Then, use it as a keyword argument in the next call.

```julia
conversation = aigenerate("Hi! I'm John"; return_all=true)
@info last(conversation) # display the response

# follow-up (notice that we provide past messages as conversation kwarg
conversation = aigenerate("What's my name?"; return_all=true, conversation)

## [ Info: Tokens: 50 @ Cost: $0.0 in 1.0 seconds
## 5-element Vector{PromptingTools.AbstractMessage}:
##  PromptingTools.SystemMessage("Act as a helpful AI assistant")
##  PromptingTools.UserMessage("Hi! I'm John")
##  AIMessage("Hello John! How can I assist you today?")
##  PromptingTools.UserMessage("What's my name?")
##  AIMessage("Your name is John.")
```
Notice that the last message is the response to the second request, but with `return_all=true` we can see the whole conversation from the beginning.

## Explain What Happens Under the Hood

4 Key Concepts/Objects:
- Schemas -> object of type `AbstractPromptSchema` that determines which methods are called and, hence, what providers/APIs are used
- Prompts -> the information you want to convey to the AI model
- Messages -> the basic unit of communication between the user and the AI model (eg, `UserMessage` vs `AIMessage`)
- Prompt Templates -> re-usable "prompts" with placeholders that you can replace with your inputs at the time of making the request

When you call `aigenerate`, roughly the following happens: `render` -> `UserMessage`(s) -> `render` -> `OpenAI.create_chat` -> ... -> `AIMessage`.

We'll deep dive into an example in the end.

### Schemas

For your "message" to reach an AI model, it needs to be formatted and sent to the right place.

We leverage the multiple dispatch around the "schemas" to pick the right logic.
All schemas are subtypes of `AbstractPromptSchema` and there are many subtypes, eg, `OpenAISchema <: AbstractOpenAISchema <:AbstractPromptSchema`.

For example, if you provide `schema = OpenAISchema()`, the system knows that:
- it will have to format any user inputs to OpenAI's "message specification" (a vector of dictionaries, see their API documentation). Function `render(OpenAISchema(),...)` will take care of the rendering.
- it will have to send the message to OpenAI's API. We will use the amazing `OpenAI.jl` package to handle the communication.

### Prompts

Prompt is loosely the information you want to convey to the AI model. It can be a question, a statement, or a command. It can have instructions or some context, eg, previous conversation.

You need to remember that Large Language Models (LLMs) are **stateless**. They don't remember the previous conversation/request, so you need to provide the whole history/context every time (similar to how REST APIs work).

Prompts that we send to the LLMs are effectively a sequence of messages (`<:AbstractMessage`).

### Messages

Messages are the basic unit of communication between the user and the AI model. 

There are 5 main types of messages (`<:AbstractMessage`):

- `SystemMessage` - this contains information about the "system", eg, how it should behave, format its output, etc. (eg, `You're a world-class Julia programmer. You write brief and concise code.)
- `UserMessage` - the information "from the user", ie, your question/statement/task
- `UserMessageWithImages` - the same as `UserMessage`, but with images (URLs or Base64-encoded images)
- `AIMessage` - the response from the AI model, when the "output" is text
- `DataMessage` - the response from the AI model, when the "output" is data, eg, embeddings with `aiembed` or user-defined structs with `aiextract`

### Prompt Templates

We want to have re-usable "prompts", so we provide you with a system to retrieve pre-defined prompts with placeholders (eg, `{{name}}`) that you can replace with your inputs at the time of making the request.

"AI Templates" as we call them (`AITemplate`) are usually a vector of `SystemMessage` and a `UserMessage` with specific purpose/task.

For example, the template `:AssistantAsk` is defined loosely as:

```julia
 template = [SystemMessage("You are a world-class AI assistant. Your communication is brief and concise. You're precise and answer only when you're confident in the high quality of your answer."),
             UserMessage("# Question\n\n{{ask}}")]
```

Notice that we have a placeholder `ask` (`{{ask}}`) that you can replace with your question without having to re-write the generic system instructions.

When you provide a Symbol (eg, `:AssistantAsk`) to ai* functions, thanks to the multiple dispatch, it recognizes that it's an `AITemplate(:AssistantAsk)` and looks it up.

You can discover all available templates with `aitemplates("some keyword")` or just see the details of some template `aitemplates(:AssistantAsk)`.

### Walkthrough Example

```julia
using PromptingTools
const PT = PromptingTools

# Let's say this is our ask
msg = aigenerate(:AssistantAsk; ask="What is the capital of France?")

# it is effectively the same as:
msg = aigenerate(PT.OpenAISchema(), PT.AITemplate(:AssistantAsk); ask="What is the capital of France?", model="gpt3t")
```

There is no `model` provided, so we use the default `PT.MODEL_CHAT` (effectively GPT3.5-Turbo). Then we look it up in `PT.MDOEL_REGISTRY` and use the associated schema for it (`OpenAISchema` in this case).

The next step is to render the template, replace the placeholders and render it for the OpenAI model.

```julia
# Let's remember out schema
schema = PT.OpenAISchema()
ask = "What is the capital of France?"
```

First, we obtain the template (no placeholder replacement yet) and "expand it"
```julia
template_rendered = PT.render(schema, AITemplate(:AssistantAsk); ask)
```

```plaintext
2-element Vector{PromptingTools.AbstractChatMessage}:
  PromptingTools.SystemMessage("You are a world-class AI assistant. Your communication is brief and concise. You're precise and answer only when you're confident in the high quality of your answer.")
  PromptingTools.UserMessage{String}("# Question\n\n{{ask}}", [:ask], :usermessage)
```

Second, we replace the placeholders
```julia
rendered_for_api = PT.render(schema, template_rendered;  ask)
```
  
```plaintext
2-element Vector{Dict{String, Any}}:
  Dict("role" => "system", "content" => "You are a world-class AI assistant. Your communication is brief and concise. You're precise and answer only when you're confident in the high quality of your answer.")
  Dict("role" => "user", "content" => "# Question\n\nWhat is the capital of France?")
```

Notice that the placeholders are only replaced in the second step. The final output here is a vector of messages with "role" and "content" keys, which is the format required by the OpenAI API.

As a side note, under the hood, the second step is done in two steps:

- replace the placeholders `messages_rendered = PT.render(PT.NoSchema(), template_rendered; ask)` -> returns a vector of Messages!
- then, we convert the messages to the format required by the provider/schema `PT.render(schema, messages_rendered)` -> returns the OpenAI formatted messages


Next, we send the above `rendered_for_api` to the OpenAI API and get the response back.

```julia
using OpenAI
OpenAI.create_chat(api_key, model, rendered_for_api)
```

The last step is to take the JSON response from the API and convert it to the `AIMessage` object.

```julia
# simplification for educational purposes
msg = AIMessage(; content = r.response[:choices][1][:message][:content])
```
In practice, there are more fields we extract, so we define a utility for it: `PT.response_to_message`. Especially, since with parameter `n`, you can request multiple AI responses at once, so we want to re-use our response processing logic.

That's it! I hope you've learned something new about how PromptingTools.jl works under the hood.